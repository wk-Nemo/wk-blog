---
title: go的程序结构
date: 2021-10-29 17:06:13
tags:
---


## go程序结构

- 一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件
- 每个源文件中以包的声明语句开始，说明该源文件是属于哪个包
- 包声明语句之后是import语句导入依赖的其它包
- 然后是包一级的类型、变量、常量、函数的声明语句，包一级声明语句声明的名字可在整个包对应的每个源文件中访问
- 最后是各个局部声明，局部声明的名字就只能在函数内部很小的范围被访问。

## 声明

Go语言主要有四种类型的声明语句：

- var：变量
- const：常量
- type：类型
- func：函数实体

```go
package main

import "fmt"

// 包一级声明
const boilingF = 212.0

func main() {
    // 局部声明
    var f = boilingF
    var c = (f - 32) * 5 / 9
    fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
    // Output:
    // boiling point = 212°F or 100°C
}
```

## 变量
var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

```
var 变量名字 类型 = 表达式
```

其中“*类型*”或“*= 表达式*”两个部分可以省略其中的一个。
- 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。
- 如果初始化表达式被省略，那么将用零值初始化该变量。 
    - 数值类型变量对应的零值是0
    - 布尔类型变量对应的零值是false
    - 字符串类型对应的零值是空字符串
    - 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil
    - 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
    
##### 1. 简短变量声明

```go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0

// 同时声明多个变量
i, j := 0, 1
```
- 简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。
- 简短变量声明语句中必须至少要声明一个新的变量，否则编译无法通过

##### 2. 指针

一个指针的值是另一个变量的地址。

```go
x := 1
p := &x         // &x 取x的内存地址
fmt.Println(*p) // "1"
*p = 2          // *p p指针指向的变量的值
fmt.Println(x)  // "2"
```

##### 3. new 函数

另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为`*T`。

```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

new函数类似是一种语法糖，用new创建变量和普通变量声明语句方式创建变量没有什么区别

```go
func newInt() *int {
    return new(int)
}

func newInt() *int {
    var dummy int
    return &dummy
}
```

上面了解了变量的声明，下面继续学习**变量的生命周期**

- 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。
- 而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量

## 赋值

```go
x = 1                       // 命名变量的赋值
*p = true                   // 通过指针间接赋值
person.name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
```

**元组赋值：** 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

```go
x, y = y, x

a[i], a[j] = a[j], a[i]
```

**可赋值性：** 赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为。
- 函数调用会隐式地将调用参数的值赋值给函数的参数变量
- 一个返回语句会隐式地将返回操作的值赋值给结果变量
- 一个复合类型的字面量也会产生赋值行为。

## 类型
一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

```
type 类型名字 底层类型
```

类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。

```go
package tempconv

import "fmt"

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如`(*int)(0)`）。
- 只有当两个类型的底层基础类型相同时，才允许这种转型操作
- 或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
- 如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。

## 包和文件

Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；

- 每个包都对应一个独立的名字空间。
    
   在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。
   
- 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。

    在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的











